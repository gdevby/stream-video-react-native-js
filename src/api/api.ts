/* tslint:disable */
/* eslint-disable */
/**
 * Stream application
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbstractJsonSchemaPropertyObject
 */
export interface AbstractJsonSchemaPropertyObject {
    /**
     * 
     * @type {string}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbstractJsonSchemaPropertyObject
     */
    'readOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface BroadcastRequestBody
 */
export interface BroadcastRequestBody {
    /**
     * 
     * @type {number}
     * @memberof BroadcastRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BroadcastRequestBody
     */
    'status': BroadcastRequestBodyStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BroadcastRequestBody
     */
    'dateOfStart': string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastRequestBody
     */
    'dateOfEnd'?: string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastRequestBody
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastRequestBody
     */
    'streamName': string;
}

export const BroadcastRequestBodyStatusEnum = {
    Online: 'Online',
    Future: 'Future',
    Finished: 'Finished'
} as const;

export type BroadcastRequestBodyStatusEnum = typeof BroadcastRequestBodyStatusEnum[keyof typeof BroadcastRequestBodyStatusEnum];

/**
 * 
 * @export
 * @interface CollectionModelObject
 */
export interface CollectionModelObject {
    /**
     * 
     * @type {CollectionModelObjectEmbedded}
     * @memberof CollectionModelObject
     */
    '_embedded'?: CollectionModelObjectEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelObjectEmbedded
 */
export interface CollectionModelObjectEmbedded {
    /**
     * 
     * @type {Array<object>}
     * @memberof CollectionModelObjectEmbedded
     */
    'objects'?: Array<object>;
}
/**
 * 
 * @export
 * @interface CollectionModelReferenceMaterial
 */
export interface CollectionModelReferenceMaterial {
    /**
     * 
     * @type {CollectionModelReferenceMaterialEmbedded}
     * @memberof CollectionModelReferenceMaterial
     */
    '_embedded'?: CollectionModelReferenceMaterialEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof CollectionModelReferenceMaterial
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface CollectionModelReferenceMaterialEmbedded
 */
export interface CollectionModelReferenceMaterialEmbedded {
    /**
     * 
     * @type {Array<ReferenceMaterialResponse>}
     * @memberof CollectionModelReferenceMaterialEmbedded
     */
    'referenceMaterials'?: Array<ReferenceMaterialResponse>;
}
/**
 * 
 * @export
 * @interface EntityModelBroadcast
 */
export interface EntityModelBroadcast {
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcast
     */
    'status': EntityModelBroadcastStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcast
     */
    'dateOfStart': string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcast
     */
    'dateOfEnd'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcast
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcast
     */
    'streamName': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelBroadcast
     */
    '_links'?: { [key: string]: Link; };
}

export const EntityModelBroadcastStatusEnum = {
    Online: 'Online',
    Future: 'Future',
    Finished: 'Finished'
} as const;

export type EntityModelBroadcastStatusEnum = typeof EntityModelBroadcastStatusEnum[keyof typeof EntityModelBroadcastStatusEnum];

/**
 * 
 * @export
 * @interface EntityModelBroadcastDto
 */
export interface EntityModelBroadcastDto {
    /**
     * 
     * @type {number}
     * @memberof EntityModelBroadcastDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcastDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcastDto
     */
    'dateOfStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcastDto
     */
    'dateOfEnd'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcastDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelBroadcastDto
     */
    'streamName'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelBroadcastDto
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelMaterialFolder
 */
export interface EntityModelMaterialFolder {
    /**
     * 
     * @type {string}
     * @memberof EntityModelMaterialFolder
     */
    'folderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelMaterialFolder
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelMaterialFolder
     */
    'pathToLogo'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelMaterialFolder
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPlaylist
 */
export interface EntityModelPlaylist {
    /**
     * 
     * @type {string}
     * @memberof EntityModelPlaylist
     */
    'previewPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPlaylist
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPlaylist
     */
    'link'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPlaylist
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelPlaylistDto
 */
export interface EntityModelPlaylistDto {
    /**
     * 
     * @type {number}
     * @memberof EntityModelPlaylistDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPlaylistDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelPlaylistDto
     */
    'link'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelPlaylistDto
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelReferenceMaterial
 */
export interface EntityModelReferenceMaterial {
    /**
     * 
     * @type {string}
     * @memberof EntityModelReferenceMaterial
     */
    'materialName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelReferenceMaterial
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelReferenceMaterial
     */
    'localPath': string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelReferenceMaterial
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface EntityModelUserDto
 */
export interface EntityModelUserDto {
    /**
     * 
     * @type {number}
     * @memberof EntityModelUserDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUserDto
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUserDto
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityModelUserDto
     */
    'role'?: string;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof EntityModelUserDto
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'type'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof Item
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Item
     */
    'requiredProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface JsonSchema
 */
export interface JsonSchema {
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: AbstractJsonSchemaPropertyObject; }}
     * @memberof JsonSchema
     */
    'properties'?: { [key: string]: AbstractJsonSchemaPropertyObject; };
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonSchema
     */
    'requiredProperties'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Item; }}
     * @memberof JsonSchema
     */
    'definitions'?: { [key: string]: Item; };
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonSchema
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface JwtAuthenticationResponse
 */
export interface JwtAuthenticationResponse {
    /**
     * 
     * @type {string}
     * @memberof JwtAuthenticationResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'hreflang'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'deprecation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface MaterialFolderDto
 */
export interface MaterialFolderDto {
    /**
     * 
     * @type {number}
     * @memberof MaterialFolderDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MaterialFolderDto
     */
    'folderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialFolderDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ReferenceMaterialDto>}
     * @memberof MaterialFolderDto
     */
    'materials'?: Array<ReferenceMaterialDto>;
}
/**
 * 
 * @export
 * @interface MaterialFolderRequestBody
 */
export interface MaterialFolderRequestBody {
    /**
     * 
     * @type {number}
     * @memberof MaterialFolderRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MaterialFolderRequestBody
     */
    'folderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialFolderRequestBody
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaterialFolderRequestBody
     */
    'pathToLogo'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MaterialFolderRequestBody
     */
    'materials'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelBroadcast
 */
export interface PagedModelEntityModelBroadcast {
    /**
     * 
     * @type {PagedModelEntityModelBroadcastEmbedded}
     * @memberof PagedModelEntityModelBroadcast
     */
    '_embedded'?: PagedModelEntityModelBroadcastEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelBroadcast
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelBroadcast
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelBroadcastDto
 */
export interface PagedModelEntityModelBroadcastDto {
    /**
     * 
     * @type {PagedModelEntityModelBroadcastDtoEmbedded}
     * @memberof PagedModelEntityModelBroadcastDto
     */
    '_embedded'?: PagedModelEntityModelBroadcastDtoEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelBroadcastDto
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelBroadcastDto
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelBroadcastDtoEmbedded
 */
export interface PagedModelEntityModelBroadcastDtoEmbedded {
    /**
     * 
     * @type {Array<EntityModelBroadcastDto>}
     * @memberof PagedModelEntityModelBroadcastDtoEmbedded
     */
    'broadcastDtoes'?: Array<EntityModelBroadcastDto>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelBroadcastEmbedded
 */
export interface PagedModelEntityModelBroadcastEmbedded {
    /**
     * 
     * @type {Array<EntityModelBroadcast>}
     * @memberof PagedModelEntityModelBroadcastEmbedded
     */
    'broadcasts'?: Array<EntityModelBroadcast>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMaterialFolder
 */
export interface PagedModelEntityModelMaterialFolder {
    /**
     * 
     * @type {PagedModelEntityModelMaterialFolderEmbedded}
     * @memberof PagedModelEntityModelMaterialFolder
     */
    '_embedded'?: PagedModelEntityModelMaterialFolderEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelMaterialFolder
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelMaterialFolder
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelMaterialFolderEmbedded
 */
export interface PagedModelEntityModelMaterialFolderEmbedded {
    /**
     * 
     * @type {Array<EntityModelMaterialFolder>}
     * @memberof PagedModelEntityModelMaterialFolderEmbedded
     */
    'materialFolders'?: Array<EntityModelMaterialFolder>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPlaylist
 */
export interface PagedModelEntityModelPlaylist {
    /**
     * 
     * @type {PagedModelEntityModelPlaylistEmbedded}
     * @memberof PagedModelEntityModelPlaylist
     */
    '_embedded'?: PagedModelEntityModelPlaylistEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPlaylist
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPlaylist
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPlaylistDto
 */
export interface PagedModelEntityModelPlaylistDto {
    /**
     * 
     * @type {PagedModelEntityModelPlaylistDtoEmbedded}
     * @memberof PagedModelEntityModelPlaylistDto
     */
    '_embedded'?: PagedModelEntityModelPlaylistDtoEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelPlaylistDto
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelPlaylistDto
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPlaylistDtoEmbedded
 */
export interface PagedModelEntityModelPlaylistDtoEmbedded {
    /**
     * 
     * @type {Array<EntityModelPlaylistDto>}
     * @memberof PagedModelEntityModelPlaylistDtoEmbedded
     */
    'playlistDtoes'?: Array<EntityModelPlaylistDto>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelPlaylistEmbedded
 */
export interface PagedModelEntityModelPlaylistEmbedded {
    /**
     * 
     * @type {Array<EntityModelPlaylist>}
     * @memberof PagedModelEntityModelPlaylistEmbedded
     */
    'playlists'?: Array<EntityModelPlaylist>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelReferenceMaterial
 */
export interface PagedModelEntityModelReferenceMaterial {
    /**
     * 
     * @type {PagedModelEntityModelReferenceMaterialEmbedded}
     * @memberof PagedModelEntityModelReferenceMaterial
     */
    '_embedded'?: PagedModelEntityModelReferenceMaterialEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelReferenceMaterial
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelReferenceMaterial
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelReferenceMaterialEmbedded
 */
export interface PagedModelEntityModelReferenceMaterialEmbedded {
    /**
     * 
     * @type {Array<EntityModelReferenceMaterial>}
     * @memberof PagedModelEntityModelReferenceMaterialEmbedded
     */
    'referenceMaterials'?: Array<EntityModelReferenceMaterial>;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserDto
 */
export interface PagedModelEntityModelUserDto {
    /**
     * 
     * @type {PagedModelEntityModelUserDtoEmbedded}
     * @memberof PagedModelEntityModelUserDto
     */
    '_embedded'?: PagedModelEntityModelUserDtoEmbedded;
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof PagedModelEntityModelUserDto
     */
    '_links'?: { [key: string]: Link; };
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModelEntityModelUserDto
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface PagedModelEntityModelUserDtoEmbedded
 */
export interface PagedModelEntityModelUserDtoEmbedded {
    /**
     * 
     * @type {Array<EntityModelUserDto>}
     * @memberof PagedModelEntityModelUserDtoEmbedded
     */
    'userDtoes'?: Array<EntityModelUserDto>;
}
/**
 * 
 * @export
 * @interface PlaylistDto
 */
export interface PlaylistDto {
    /**
     * 
     * @type {number}
     * @memberof PlaylistDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDto
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistRequestBody
 */
export interface PlaylistRequestBody {
    /**
     * 
     * @type {number}
     * @memberof PlaylistRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistRequestBody
     */
    'previewPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistRequestBody
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistRequestBody
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface ReferenceMaterialDto
 */
export interface ReferenceMaterialDto {
    /**
     * 
     * @type {number}
     * @memberof ReferenceMaterialDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialDto
     */
    'materialName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialDto
     */
    'fileName'?: string;
}
/**
 * 
 * @export
 * @interface ReferenceMaterialRequestBody
 */
export interface ReferenceMaterialRequestBody {
    /**
     * 
     * @type {number}
     * @memberof ReferenceMaterialRequestBody
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialRequestBody
     */
    'materialName': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialRequestBody
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialRequestBody
     */
    'localPath': string;
}
/**
 * 
 * @export
 * @interface ReferenceMaterialResponse
 */
export interface ReferenceMaterialResponse {
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialResponse
     */
    'materialName': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialResponse
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof ReferenceMaterialResponse
     */
    'localPath': string;
}
/**
 * 
 * @export
 * @interface RepresentationModelObject
 */
export interface RepresentationModelObject {
    /**
     * 
     * @type {{ [key: string]: Link; }}
     * @memberof RepresentationModelObject
     */
    '_links'?: { [key: string]: Link; };
}
/**
 * 
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
    /**
     * 
     * @type {string}
     * @memberof SignInRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SignInRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'firstname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'lastname': string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'role'?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRights: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteRights', 'username', username)
            const localVarPath = `/auth/admin/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveRights: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('giveRights', 'username', username)
            const localVarPath = `/auth/admin/give`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (signInRequest: SignInRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInRequest' is not null or undefined
            assertParamExists('signIn', 'signInRequest', signInRequest)
            const localVarPath = `/auth/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signUp', 'signUpRequest', signUpRequest)
            const localVarPath = `/auth/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRights(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRights(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.deleteRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async giveRights(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.giveRights(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.giveRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(signInRequest: SignInRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtAuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(signInRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.signIn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtAuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRights(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.deleteRights(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveRights(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.giveRights(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInRequest} signInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(signInRequest: SignInRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse> {
            return localVarFp.signIn(signInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse> {
            return localVarFp.signUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public deleteRights(username: string, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).deleteRights(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public giveRights(username: string, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).giveRights(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInRequest} signInRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public signIn(signInRequest: SignInRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).signIn(signInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).signUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FrontApi - axios parameter creator
 * @export
 */
export const FrontApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [folderName] 
         * @param {string} [description] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeFolder: async (id: number, folderName?: string, description?: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeFolder', 'id', id)
            const localVarPath = `/admin/referenceMaterials/folder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (folderName !== undefined) {
                localVarQueryParameter['folderName'] = folderName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [link] 
         * @param {string} [title] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlaylist: async (id: number, link?: string, title?: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changePlaylist', 'id', id)
            const localVarPath = `/playlist/patch/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} description 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (name: string, description: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createFolder', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createFolder', 'description', description)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createFolder', 'file', file)
            const localVarPath = `/admin/referenceMaterials/folder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} title 
         * @param {string} link 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (title: string, link: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('createPlaylist', 'title', title)
            // verify required parameter 'link' is not null or undefined
            assertParamExists('createPlaylist', 'link', link)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createPlaylist', 'file', file)
            const localVarPath = `/playlist/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (link !== undefined) {
                localVarQueryParameter['link'] = link;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFolder', 'id', id)
            const localVarPath = `/admin/referenceMaterials/folder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMaterial', 'id', id)
            const localVarPath = `/admin/referenceMaterials/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlaylist', 'id', id)
            const localVarPath = `/playlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadFile', 'id', id)
            const localVarPath = `/admin/referenceMaterials/download/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderLogo: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderLogo', 'folderId', folderId)
            const localVarPath = `/admin/referenceMaterials/view/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/referenceMaterials/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaterialsInFolder: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getMaterialsInFolder', 'folderId', folderId)
            const localVarPath = `/admin/referenceMaterials/materials/{folderId}`
                .replace(`{${"folderId"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaylist', 'id', id)
            const localVarPath = `/playlist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {GetPlaylist1OrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist1: async (page?: number, size?: number, sort?: string, order?: GetPlaylist1OrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlist/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} folderName 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMaterial: async (name: string, folderName: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('uploadMaterial', 'name', name)
            // verify required parameter 'folderName' is not null or undefined
            assertParamExists('uploadMaterial', 'folderName', folderName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadMaterial', 'file', file)
            const localVarPath = `/admin/referenceMaterials/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (folderName !== undefined) {
                localVarQueryParameter['folderName'] = folderName;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewImage: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewImage', 'id', id)
            const localVarPath = `/playlist/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontApi - functional programming interface
 * @export
 */
export const FrontApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [folderName] 
         * @param {string} [description] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeFolder(id: number, folderName?: string, description?: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialFolderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeFolder(id, folderName, description, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.changeFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [link] 
         * @param {string} [title] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePlaylist(id: number, link?: string, title?: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePlaylist(id, link, title, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.changePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {string} description 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(name: string, description: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialFolderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(name, description, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} title 
         * @param {string} link 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(title: string, link: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(title, link, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.createPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaterialFolderDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMaterial(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceMaterialDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMaterial(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.deleteMaterial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.deletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderLogo(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderLogo(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.getFolderLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaterialFolderDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.getFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaterialsInFolder(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReferenceMaterialDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaterialsInFolder(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.getMaterialsInFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.getPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {GetPlaylist1OrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist1(page?: number, size?: number, sort?: string, order?: GetPlaylist1OrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPlaylistDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist1(page, size, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.getPlaylist1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {string} folderName 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMaterial(name: string, folderName: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferenceMaterialDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMaterial(name, folderName, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.uploadMaterial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewImage(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontApi.viewImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FrontApi - factory interface
 * @export
 */
export const FrontApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {string} [folderName] 
         * @param {string} [description] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeFolder(id: number, folderName?: string, description?: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<MaterialFolderDto> {
            return localVarFp.changeFolder(id, folderName, description, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} [link] 
         * @param {string} [title] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePlaylist(id: number, link?: string, title?: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDto> {
            return localVarFp.changePlaylist(id, link, title, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} description 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(name: string, description: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<MaterialFolderDto> {
            return localVarFp.createFolder(name, description, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} title 
         * @param {string} link 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(title: string, link: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDto> {
            return localVarFp.createPlaylist(title, link, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MaterialFolderDto> {
            return localVarFp.deleteFolder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaterial(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceMaterialDto> {
            return localVarFp.deleteMaterial(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDto> {
            return localVarFp.deletePlaylist(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(id: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderLogo(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getFolderLogo(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(options?: RawAxiosRequestConfig): AxiosPromise<Array<MaterialFolderDto>> {
            return localVarFp.getFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaterialsInFolder(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ReferenceMaterialDto>> {
            return localVarFp.getMaterialsInFolder(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDto> {
            return localVarFp.getPlaylist(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {GetPlaylist1OrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist1(page?: number, size?: number, sort?: string, order?: GetPlaylist1OrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelPlaylistDto> {
            return localVarFp.getPlaylist1(page, size, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} folderName 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMaterial(name: string, folderName: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<ReferenceMaterialDto> {
            return localVarFp.uploadMaterial(name, folderName, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewImage(id: number, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.viewImage(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontApi - object-oriented interface
 * @export
 * @class FrontApi
 * @extends {BaseAPI}
 */
export class FrontApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {string} [folderName] 
     * @param {string} [description] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public changeFolder(id: number, folderName?: string, description?: string, file?: File, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).changeFolder(id, folderName, description, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} [link] 
     * @param {string} [title] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public changePlaylist(id: number, link?: string, title?: string, file?: File, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).changePlaylist(id, link, title, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {string} description 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public createFolder(name: string, description: string, file: File, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).createFolder(name, description, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} title 
     * @param {string} link 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public createPlaylist(title: string, link: string, file: File, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).createPlaylist(title, link, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public deleteFolder(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).deleteFolder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public deleteMaterial(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).deleteMaterial(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public deletePlaylist(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).deletePlaylist(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public downloadFile(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).downloadFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} folderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public getFolderLogo(folderId: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).getFolderLogo(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public getFolders(options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).getFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} folderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public getMaterialsInFolder(folderId: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).getMaterialsInFolder(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public getPlaylist(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).getPlaylist(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sort] 
     * @param {GetPlaylist1OrderEnum} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public getPlaylist1(page?: number, size?: number, sort?: string, order?: GetPlaylist1OrderEnum, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).getPlaylist1(page, size, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {string} folderName 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public uploadMaterial(name: string, folderName: string, file: File, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).uploadMaterial(name, folderName, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontApi
     */
    public viewImage(id: number, options?: RawAxiosRequestConfig) {
        return FrontApiFp(this.configuration).viewImage(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPlaylist1OrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetPlaylist1OrderEnum = typeof GetPlaylist1OrderEnum[keyof typeof GetPlaylist1OrderEnum];


/**
 * FrontMobileApi - axios parameter creator
 * @export
 */
export const FrontMobileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllBroadcasts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/broadcast/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStreamFiles: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteStreamFiles', 'name', name)
            const localVarPath = `/broadcast/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endStream: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endStream', 'body', body)
            const localVarPath = `/broadcast/end`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {GetSortedBroadcastStatusEnum} [status] 
         * @param {string} [title] 
         * @param {string} [sort] 
         * @param {GetSortedBroadcastOrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedBroadcast: async (page?: number, size?: number, status?: GetSortedBroadcastStatusEnum, title?: string, sort?: string, order?: GetSortedBroadcastOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/broadcast/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startStream: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('startStream', 'body', body)
            const localVarPath = `/broadcast/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontMobileApi - functional programming interface
 * @export
 */
export const FrontMobileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontMobileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllBroadcasts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllBroadcasts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileApi.deleteAllBroadcasts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStreamFiles(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStreamFiles(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileApi.deleteStreamFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endStream(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endStream(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileApi.endStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {GetSortedBroadcastStatusEnum} [status] 
         * @param {string} [title] 
         * @param {string} [sort] 
         * @param {GetSortedBroadcastOrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSortedBroadcast(page?: number, size?: number, status?: GetSortedBroadcastStatusEnum, title?: string, sort?: string, order?: GetSortedBroadcastOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelBroadcastDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSortedBroadcast(page, size, status, title, sort, order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileApi.getSortedBroadcast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startStream(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startStream(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileApi.startStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FrontMobileApi - factory interface
 * @export
 */
export const FrontMobileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontMobileApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllBroadcasts(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteAllBroadcasts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStreamFiles(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteStreamFiles(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endStream(body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.endStream(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {GetSortedBroadcastStatusEnum} [status] 
         * @param {string} [title] 
         * @param {string} [sort] 
         * @param {GetSortedBroadcastOrderEnum} [order] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedBroadcast(page?: number, size?: number, status?: GetSortedBroadcastStatusEnum, title?: string, sort?: string, order?: GetSortedBroadcastOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelBroadcastDto> {
            return localVarFp.getSortedBroadcast(page, size, status, title, sort, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startStream(body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.startStream(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontMobileApi - object-oriented interface
 * @export
 * @class FrontMobileApi
 * @extends {BaseAPI}
 */
export class FrontMobileApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileApi
     */
    public deleteAllBroadcasts(options?: RawAxiosRequestConfig) {
        return FrontMobileApiFp(this.configuration).deleteAllBroadcasts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileApi
     */
    public deleteStreamFiles(name: string, options?: RawAxiosRequestConfig) {
        return FrontMobileApiFp(this.configuration).deleteStreamFiles(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileApi
     */
    public endStream(body: string, options?: RawAxiosRequestConfig) {
        return FrontMobileApiFp(this.configuration).endStream(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {GetSortedBroadcastStatusEnum} [status] 
     * @param {string} [title] 
     * @param {string} [sort] 
     * @param {GetSortedBroadcastOrderEnum} [order] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileApi
     */
    public getSortedBroadcast(page?: number, size?: number, status?: GetSortedBroadcastStatusEnum, title?: string, sort?: string, order?: GetSortedBroadcastOrderEnum, options?: RawAxiosRequestConfig) {
        return FrontMobileApiFp(this.configuration).getSortedBroadcast(page, size, status, title, sort, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileApi
     */
    public startStream(body: string, options?: RawAxiosRequestConfig) {
        return FrontMobileApiFp(this.configuration).startStream(body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSortedBroadcastStatusEnum = {
    Online: 'Online',
    Future: 'Future',
    Finished: 'Finished'
} as const;
export type GetSortedBroadcastStatusEnum = typeof GetSortedBroadcastStatusEnum[keyof typeof GetSortedBroadcastStatusEnum];
/**
 * @export
 */
export const GetSortedBroadcastOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;
export type GetSortedBroadcastOrderEnum = typeof GetSortedBroadcastOrderEnum[keyof typeof GetSortedBroadcastOrderEnum];


/**
 * FrontMobileGETApi - axios parameter creator
 * @export
 */
export const FrontMobileGETApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceBroadcastDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceBroadcastDelete', 'id', id)
            const localVarPath = `/admin/broadcasts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePlaylistDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourcePlaylistDelete', 'id', id)
            const localVarPath = `/admin/playlists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceReferencematerialDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceReferencematerialDelete', 'id', id)
            const localVarPath = `/admin/referenceMaterials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExecuteSearchBroadcastGetStatusEnum} [status] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet: async (status?: ExecuteSearchBroadcastGetStatusEnum, page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/broadcasts/search/findAllByStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet1: async (title?: string, page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/broadcasts/search/findAllByTitle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [streamName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet2: async (streamName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/broadcasts/search/findByStreamName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (streamName !== undefined) {
                localVarQueryParameter['streamName'] = streamName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet3: async (title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/broadcasts/search/findByTitle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-broadcast
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceBroadcastGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-playlist
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePlaylistGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-referencematerial
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceReferencematerialGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/referenceMaterials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceBroadcastGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceBroadcastGet', 'id', id)
            const localVarPath = `/admin/broadcasts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePlaylistGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourcePlaylistGet', 'id', id)
            const localVarPath = `/admin/playlists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceReferencematerialGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceReferencematerialGet', 'id', id)
            const localVarPath = `/admin/referenceMaterials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceBroadcastPatch: async (id: string, broadcastRequestBody: BroadcastRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceBroadcastPatch', 'id', id)
            // verify required parameter 'broadcastRequestBody' is not null or undefined
            assertParamExists('patchItemResourceBroadcastPatch', 'broadcastRequestBody', broadcastRequestBody)
            const localVarPath = `/admin/broadcasts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePlaylistPatch: async (id: string, playlistRequestBody: PlaylistRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourcePlaylistPatch', 'id', id)
            // verify required parameter 'playlistRequestBody' is not null or undefined
            assertParamExists('patchItemResourcePlaylistPatch', 'playlistRequestBody', playlistRequestBody)
            const localVarPath = `/admin/playlists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceReferencematerialPatch: async (id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceReferencematerialPatch', 'id', id)
            // verify required parameter 'referenceMaterialRequestBody' is not null or undefined
            assertParamExists('patchItemResourceReferencematerialPatch', 'referenceMaterialRequestBody', referenceMaterialRequestBody)
            const localVarPath = `/admin/referenceMaterials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(referenceMaterialRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-broadcast
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceBroadcastPost: async (broadcastRequestBody: BroadcastRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'broadcastRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceBroadcastPost', 'broadcastRequestBody', broadcastRequestBody)
            const localVarPath = `/admin/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-playlist
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePlaylistPost: async (playlistRequestBody: PlaylistRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistRequestBody' is not null or undefined
            assertParamExists('postCollectionResourcePlaylistPost', 'playlistRequestBody', playlistRequestBody)
            const localVarPath = `/admin/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-referencematerial
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceReferencematerialPost: async (referenceMaterialRequestBody: ReferenceMaterialRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'referenceMaterialRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceReferencematerialPost', 'referenceMaterialRequestBody', referenceMaterialRequestBody)
            const localVarPath = `/admin/referenceMaterials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(referenceMaterialRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceBroadcastPut: async (id: string, broadcastRequestBody: BroadcastRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceBroadcastPut', 'id', id)
            // verify required parameter 'broadcastRequestBody' is not null or undefined
            assertParamExists('putItemResourceBroadcastPut', 'broadcastRequestBody', broadcastRequestBody)
            const localVarPath = `/admin/broadcasts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(broadcastRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePlaylistPut: async (id: string, playlistRequestBody: PlaylistRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourcePlaylistPut', 'id', id)
            // verify required parameter 'playlistRequestBody' is not null or undefined
            assertParamExists('putItemResourcePlaylistPut', 'playlistRequestBody', playlistRequestBody)
            const localVarPath = `/admin/playlists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceReferencematerialPut: async (id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceReferencematerialPut', 'id', id)
            // verify required parameter 'referenceMaterialRequestBody' is not null or undefined
            assertParamExists('putItemResourceReferencematerialPut', 'referenceMaterialRequestBody', referenceMaterialRequestBody)
            const localVarPath = `/admin/referenceMaterials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(referenceMaterialRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontMobileGETApi - functional programming interface
 * @export
 */
export const FrontMobileGETApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontMobileGETApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceBroadcastDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceBroadcastDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.deleteItemResourceBroadcastDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourcePlaylistDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourcePlaylistDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.deleteItemResourcePlaylistDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceReferencematerialDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceReferencematerialDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.deleteItemResourceReferencematerialDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ExecuteSearchBroadcastGetStatusEnum} [status] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchBroadcastGet(status?: ExecuteSearchBroadcastGetStatusEnum, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchBroadcastGet(status, page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.executeSearchBroadcastGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchBroadcastGet1(title?: string, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchBroadcastGet1(title, page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.executeSearchBroadcastGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [streamName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchBroadcastGet2(streamName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchBroadcastGet2(streamName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.executeSearchBroadcastGet2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchBroadcastGet3(title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchBroadcastGet3(title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.executeSearchBroadcastGet3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-broadcast
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceBroadcastGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceBroadcastGet1(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getCollectionResourceBroadcastGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-playlist
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourcePlaylistGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourcePlaylistGet1(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getCollectionResourcePlaylistGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-referencematerial
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceReferencematerialGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceReferencematerialGet1(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getCollectionResourceReferencematerialGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceBroadcastGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceBroadcastGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getItemResourceBroadcastGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourcePlaylistGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourcePlaylistGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getItemResourcePlaylistGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceReferencematerialGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceReferencematerialGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.getItemResourceReferencematerialGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceBroadcastPatch(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceBroadcastPatch(id, broadcastRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.patchItemResourceBroadcastPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourcePlaylistPatch(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourcePlaylistPatch(id, playlistRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.patchItemResourcePlaylistPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceReferencematerialPatch(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceReferencematerialPatch(id, referenceMaterialRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.patchItemResourceReferencematerialPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create-broadcast
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceBroadcastPost(broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceBroadcastPost(broadcastRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.postCollectionResourceBroadcastPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create-playlist
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourcePlaylistPost(playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourcePlaylistPost(playlistRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.postCollectionResourcePlaylistPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create-referencematerial
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceReferencematerialPost(referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceReferencematerialPost(referenceMaterialRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.postCollectionResourceReferencematerialPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceBroadcastPut(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelBroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceBroadcastPut(id, broadcastRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.putItemResourceBroadcastPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourcePlaylistPut(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelPlaylist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourcePlaylistPut(id, playlistRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.putItemResourcePlaylistPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceReferencematerialPut(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceReferencematerialPut(id, referenceMaterialRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrontMobileGETApi.putItemResourceReferencematerialPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FrontMobileGETApi - factory interface
 * @export
 */
export const FrontMobileGETApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontMobileGETApiFp(configuration)
    return {
        /**
         * delete-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceBroadcastDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemResourceBroadcastDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourcePlaylistDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemResourcePlaylistDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceReferencematerialDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemResourceReferencematerialDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExecuteSearchBroadcastGetStatusEnum} [status] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet(status?: ExecuteSearchBroadcastGetStatusEnum, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelBroadcast> {
            return localVarFp.executeSearchBroadcastGet(status, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet1(title?: string, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelBroadcast> {
            return localVarFp.executeSearchBroadcastGet1(title, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [streamName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet2(streamName?: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.executeSearchBroadcastGet2(streamName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchBroadcastGet3(title?: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.executeSearchBroadcastGet3(title, options).then((request) => request(axios, basePath));
        },
        /**
         * get-broadcast
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceBroadcastGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelBroadcast> {
            return localVarFp.getCollectionResourceBroadcastGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-playlist
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourcePlaylistGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelPlaylist> {
            return localVarFp.getCollectionResourcePlaylistGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-referencematerial
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceReferencematerialGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelReferenceMaterial> {
            return localVarFp.getCollectionResourceReferencematerialGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-broadcast
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceBroadcastGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.getItemResourceBroadcastGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-playlist
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourcePlaylistGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelPlaylist> {
            return localVarFp.getItemResourcePlaylistGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-referencematerial
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceReferencematerialGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelReferenceMaterial> {
            return localVarFp.getItemResourceReferencematerialGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceBroadcastPatch(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.patchItemResourceBroadcastPatch(id, broadcastRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourcePlaylistPatch(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelPlaylist> {
            return localVarFp.patchItemResourcePlaylistPatch(id, playlistRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceReferencematerialPatch(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelReferenceMaterial> {
            return localVarFp.patchItemResourceReferencematerialPatch(id, referenceMaterialRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-broadcast
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceBroadcastPost(broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.postCollectionResourceBroadcastPost(broadcastRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-playlist
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourcePlaylistPost(playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelPlaylist> {
            return localVarFp.postCollectionResourcePlaylistPost(playlistRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-referencematerial
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceReferencematerialPost(referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelReferenceMaterial> {
            return localVarFp.postCollectionResourceReferencematerialPost(referenceMaterialRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-broadcast
         * @param {string} id 
         * @param {BroadcastRequestBody} broadcastRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceBroadcastPut(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelBroadcast> {
            return localVarFp.putItemResourceBroadcastPut(id, broadcastRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-playlist
         * @param {string} id 
         * @param {PlaylistRequestBody} playlistRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourcePlaylistPut(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelPlaylist> {
            return localVarFp.putItemResourcePlaylistPut(id, playlistRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-referencematerial
         * @param {string} id 
         * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceReferencematerialPut(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelReferenceMaterial> {
            return localVarFp.putItemResourceReferencematerialPut(id, referenceMaterialRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontMobileGETApi - object-oriented interface
 * @export
 * @class FrontMobileGETApi
 * @extends {BaseAPI}
 */
export class FrontMobileGETApi extends BaseAPI {
    /**
     * delete-broadcast
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public deleteItemResourceBroadcastDelete(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).deleteItemResourceBroadcastDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-playlist
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public deleteItemResourcePlaylistDelete(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).deleteItemResourcePlaylistDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-referencematerial
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public deleteItemResourceReferencematerialDelete(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).deleteItemResourceReferencematerialDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExecuteSearchBroadcastGetStatusEnum} [status] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public executeSearchBroadcastGet(status?: ExecuteSearchBroadcastGetStatusEnum, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).executeSearchBroadcastGet(status, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public executeSearchBroadcastGet1(title?: string, page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).executeSearchBroadcastGet1(title, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [streamName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public executeSearchBroadcastGet2(streamName?: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).executeSearchBroadcastGet2(streamName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public executeSearchBroadcastGet3(title?: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).executeSearchBroadcastGet3(title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-broadcast
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getCollectionResourceBroadcastGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getCollectionResourceBroadcastGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-playlist
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getCollectionResourcePlaylistGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getCollectionResourcePlaylistGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-referencematerial
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getCollectionResourceReferencematerialGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getCollectionResourceReferencematerialGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-broadcast
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getItemResourceBroadcastGet(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getItemResourceBroadcastGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-playlist
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getItemResourcePlaylistGet(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getItemResourcePlaylistGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-referencematerial
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public getItemResourceReferencematerialGet(id: string, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).getItemResourceReferencematerialGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-broadcast
     * @param {string} id 
     * @param {BroadcastRequestBody} broadcastRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public patchItemResourceBroadcastPatch(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).patchItemResourceBroadcastPatch(id, broadcastRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-playlist
     * @param {string} id 
     * @param {PlaylistRequestBody} playlistRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public patchItemResourcePlaylistPatch(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).patchItemResourcePlaylistPatch(id, playlistRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-referencematerial
     * @param {string} id 
     * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public patchItemResourceReferencematerialPatch(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).patchItemResourceReferencematerialPatch(id, referenceMaterialRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-broadcast
     * @param {BroadcastRequestBody} broadcastRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public postCollectionResourceBroadcastPost(broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).postCollectionResourceBroadcastPost(broadcastRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-playlist
     * @param {PlaylistRequestBody} playlistRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public postCollectionResourcePlaylistPost(playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).postCollectionResourcePlaylistPost(playlistRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-referencematerial
     * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public postCollectionResourceReferencematerialPost(referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).postCollectionResourceReferencematerialPost(referenceMaterialRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-broadcast
     * @param {string} id 
     * @param {BroadcastRequestBody} broadcastRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public putItemResourceBroadcastPut(id: string, broadcastRequestBody: BroadcastRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).putItemResourceBroadcastPut(id, broadcastRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-playlist
     * @param {string} id 
     * @param {PlaylistRequestBody} playlistRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public putItemResourcePlaylistPut(id: string, playlistRequestBody: PlaylistRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).putItemResourcePlaylistPut(id, playlistRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-referencematerial
     * @param {string} id 
     * @param {ReferenceMaterialRequestBody} referenceMaterialRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontMobileGETApi
     */
    public putItemResourceReferencematerialPut(id: string, referenceMaterialRequestBody: ReferenceMaterialRequestBody, options?: RawAxiosRequestConfig) {
        return FrontMobileGETApiFp(this.configuration).putItemResourceReferencematerialPut(id, referenceMaterialRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ExecuteSearchBroadcastGetStatusEnum = {
    Online: 'Online',
    Future: 'Future',
    Finished: 'Finished'
} as const;
export type ExecuteSearchBroadcastGetStatusEnum = typeof ExecuteSearchBroadcastGetStatusEnum[keyof typeof ExecuteSearchBroadcastGetStatusEnum];


/**
 * MaterialFolderEntityControllerApi - axios parameter creator
 * @export
 */
export const MaterialFolderEntityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * delete-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMaterialfolderDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemResourceMaterialfolderDelete', 'id', id)
            const localVarPath = `/admin/materialFolders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-materialfolder
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMaterialfolderGet1: async (page?: number, size?: number, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/materialFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMaterialfolderGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemResourceMaterialfolderGet', 'id', id)
            const localVarPath = `/admin/materialFolders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * patch-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMaterialfolderPatch: async (id: string, materialFolderRequestBody: MaterialFolderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchItemResourceMaterialfolderPatch', 'id', id)
            // verify required parameter 'materialFolderRequestBody' is not null or undefined
            assertParamExists('patchItemResourceMaterialfolderPatch', 'materialFolderRequestBody', materialFolderRequestBody)
            const localVarPath = `/admin/materialFolders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(materialFolderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create-materialfolder
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMaterialfolderPost: async (materialFolderRequestBody: MaterialFolderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'materialFolderRequestBody' is not null or undefined
            assertParamExists('postCollectionResourceMaterialfolderPost', 'materialFolderRequestBody', materialFolderRequestBody)
            const localVarPath = `/admin/materialFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(materialFolderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMaterialfolderPut: async (id: string, materialFolderRequestBody: MaterialFolderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('putItemResourceMaterialfolderPut', 'id', id)
            // verify required parameter 'materialFolderRequestBody' is not null or undefined
            assertParamExists('putItemResourceMaterialfolderPut', 'materialFolderRequestBody', materialFolderRequestBody)
            const localVarPath = `/admin/materialFolders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(materialFolderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialFolderEntityControllerApi - functional programming interface
 * @export
 */
export const MaterialFolderEntityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialFolderEntityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * delete-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemResourceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemResourceMaterialfolderDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.deleteItemResourceMaterialfolderDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-materialfolder
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionResourceMaterialfolderGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionResourceMaterialfolderGet1(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.getCollectionResourceMaterialfolderGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemResourceMaterialfolderGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemResourceMaterialfolderGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.getItemResourceMaterialfolderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * patch-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItemResourceMaterialfolderPatch(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItemResourceMaterialfolderPatch(id, materialFolderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.patchItemResourceMaterialfolderPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create-materialfolder
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionResourceMaterialfolderPost(materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCollectionResourceMaterialfolderPost(materialFolderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.postCollectionResourceMaterialfolderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putItemResourceMaterialfolderPut(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putItemResourceMaterialfolderPut(id, materialFolderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderEntityControllerApi.putItemResourceMaterialfolderPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaterialFolderEntityControllerApi - factory interface
 * @export
 */
export const MaterialFolderEntityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialFolderEntityControllerApiFp(configuration)
    return {
        /**
         * delete-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemResourceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteItemResourceMaterialfolderDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-materialfolder
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionResourceMaterialfolderGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelMaterialFolder> {
            return localVarFp.getCollectionResourceMaterialfolderGet1(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * get-materialfolder
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemResourceMaterialfolderGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelMaterialFolder> {
            return localVarFp.getItemResourceMaterialfolderGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * patch-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItemResourceMaterialfolderPatch(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelMaterialFolder> {
            return localVarFp.patchItemResourceMaterialfolderPatch(id, materialFolderRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * create-materialfolder
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionResourceMaterialfolderPost(materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelMaterialFolder> {
            return localVarFp.postCollectionResourceMaterialfolderPost(materialFolderRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * update-materialfolder
         * @param {string} id 
         * @param {MaterialFolderRequestBody} materialFolderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putItemResourceMaterialfolderPut(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelMaterialFolder> {
            return localVarFp.putItemResourceMaterialfolderPut(id, materialFolderRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialFolderEntityControllerApi - object-oriented interface
 * @export
 * @class MaterialFolderEntityControllerApi
 * @extends {BaseAPI}
 */
export class MaterialFolderEntityControllerApi extends BaseAPI {
    /**
     * delete-materialfolder
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public deleteItemResourceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).deleteItemResourceMaterialfolderDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-materialfolder
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public getCollectionResourceMaterialfolderGet1(page?: number, size?: number, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).getCollectionResourceMaterialfolderGet1(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-materialfolder
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public getItemResourceMaterialfolderGet(id: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).getItemResourceMaterialfolderGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * patch-materialfolder
     * @param {string} id 
     * @param {MaterialFolderRequestBody} materialFolderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public patchItemResourceMaterialfolderPatch(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).patchItemResourceMaterialfolderPatch(id, materialFolderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create-materialfolder
     * @param {MaterialFolderRequestBody} materialFolderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public postCollectionResourceMaterialfolderPost(materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).postCollectionResourceMaterialfolderPost(materialFolderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-materialfolder
     * @param {string} id 
     * @param {MaterialFolderRequestBody} materialFolderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderEntityControllerApi
     */
    public putItemResourceMaterialfolderPut(id: string, materialFolderRequestBody: MaterialFolderRequestBody, options?: RawAxiosRequestConfig) {
        return MaterialFolderEntityControllerApiFp(this.configuration).putItemResourceMaterialfolderPut(id, materialFolderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaterialFolderPropertyReferenceControllerApi - axios parameter creator
 * @export
 */
export const MaterialFolderPropertyReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * patch-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceMaterialfolderPatch: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceMaterialfolderPatch', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceMaterialfolderPatch', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/admin/materialFolders/{id}/materials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceMaterialfolderPut: async (id: string, collectionModelObject: CollectionModelObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPropertyReferenceMaterialfolderPut', 'id', id)
            // verify required parameter 'collectionModelObject' is not null or undefined
            assertParamExists('createPropertyReferenceMaterialfolderPut', 'collectionModelObject', collectionModelObject)
            const localVarPath = `/admin/materialFolders/{id}/materials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collectionModelObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdMaterialfolderDelete: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceIdMaterialfolderDelete', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('deletePropertyReferenceIdMaterialfolderDelete', 'propertyId', propertyId)
            const localVarPath = `/admin/materialFolders/{id}/materials/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceMaterialfolderDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePropertyReferenceMaterialfolderDelete', 'id', id)
            const localVarPath = `/admin/materialFolders/{id}/materials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceMaterialfolderGet: async (id: string, propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceMaterialfolderGet', 'id', id)
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('followPropertyReferenceMaterialfolderGet', 'propertyId', propertyId)
            const localVarPath = `/admin/materialFolders/{id}/materials/{propertyId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceMaterialfolderGet1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('followPropertyReferenceMaterialfolderGet1', 'id', id)
            const localVarPath = `/admin/materialFolders/{id}/materials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialFolderPropertyReferenceControllerApi - functional programming interface
 * @export
 */
export const MaterialFolderPropertyReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialFolderPropertyReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * patch-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceMaterialfolderPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceMaterialfolderPatch(id, collectionModelObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.createPropertyReferenceMaterialfolderPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyReferenceMaterialfolderPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyReferenceMaterialfolderPut(id, collectionModelObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.createPropertyReferenceMaterialfolderPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceIdMaterialfolderDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceIdMaterialfolderDelete(id, propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.deletePropertyReferenceIdMaterialfolderDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePropertyReferenceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePropertyReferenceMaterialfolderDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.deletePropertyReferenceMaterialfolderDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceMaterialfolderGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceMaterialfolderGet(id, propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.followPropertyReferenceMaterialfolderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followPropertyReferenceMaterialfolderGet1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionModelReferenceMaterial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followPropertyReferenceMaterialfolderGet1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderPropertyReferenceControllerApi.followPropertyReferenceMaterialfolderGet1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaterialFolderPropertyReferenceControllerApi - factory interface
 * @export
 */
export const MaterialFolderPropertyReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialFolderPropertyReferenceControllerApiFp(configuration)
    return {
        /**
         * patch-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceMaterialfolderPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): AxiosPromise<CollectionModelReferenceMaterial> {
            return localVarFp.createPropertyReferenceMaterialfolderPatch(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * update-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {CollectionModelObject} collectionModelObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyReferenceMaterialfolderPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig): AxiosPromise<CollectionModelReferenceMaterial> {
            return localVarFp.createPropertyReferenceMaterialfolderPut(id, collectionModelObject, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceIdMaterialfolderDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceIdMaterialfolderDelete(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePropertyReferenceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePropertyReferenceMaterialfolderDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {string} propertyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceMaterialfolderGet(id: string, propertyId: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionModelReferenceMaterial> {
            return localVarFp.followPropertyReferenceMaterialfolderGet(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get-referencematerial-by-materialfolder-Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followPropertyReferenceMaterialfolderGet1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CollectionModelReferenceMaterial> {
            return localVarFp.followPropertyReferenceMaterialfolderGet1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialFolderPropertyReferenceControllerApi - object-oriented interface
 * @export
 * @class MaterialFolderPropertyReferenceControllerApi
 * @extends {BaseAPI}
 */
export class MaterialFolderPropertyReferenceControllerApi extends BaseAPI {
    /**
     * patch-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public createPropertyReferenceMaterialfolderPatch(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceMaterialfolderPatch(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {CollectionModelObject} collectionModelObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public createPropertyReferenceMaterialfolderPut(id: string, collectionModelObject: CollectionModelObject, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).createPropertyReferenceMaterialfolderPut(id, collectionModelObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public deletePropertyReferenceIdMaterialfolderDelete(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceIdMaterialfolderDelete(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public deletePropertyReferenceMaterialfolderDelete(id: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).deletePropertyReferenceMaterialfolderDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {string} propertyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public followPropertyReferenceMaterialfolderGet(id: string, propertyId: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceMaterialfolderGet(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get-referencematerial-by-materialfolder-Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderPropertyReferenceControllerApi
     */
    public followPropertyReferenceMaterialfolderGet1(id: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderPropertyReferenceControllerApiFp(this.configuration).followPropertyReferenceMaterialfolderGet1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaterialFolderSearchControllerApi - axios parameter creator
 * @export
 */
export const MaterialFolderSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [folderName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMaterialfolderGet: async (folderName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/materialFolders/search/findFirstByFolderName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (folderName !== undefined) {
                localVarQueryParameter['folderName'] = folderName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaterialFolderSearchControllerApi - functional programming interface
 * @export
 */
export const MaterialFolderSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaterialFolderSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [folderName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeSearchMaterialfolderGet(folderName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityModelMaterialFolder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeSearchMaterialfolderGet(folderName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaterialFolderSearchControllerApi.executeSearchMaterialfolderGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaterialFolderSearchControllerApi - factory interface
 * @export
 */
export const MaterialFolderSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaterialFolderSearchControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [folderName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSearchMaterialfolderGet(folderName?: string, options?: RawAxiosRequestConfig): AxiosPromise<EntityModelMaterialFolder> {
            return localVarFp.executeSearchMaterialfolderGet(folderName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaterialFolderSearchControllerApi - object-oriented interface
 * @export
 * @class MaterialFolderSearchControllerApi
 * @extends {BaseAPI}
 */
export class MaterialFolderSearchControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [folderName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaterialFolderSearchControllerApi
     */
    public executeSearchMaterialfolderGet(folderName?: string, options?: RawAxiosRequestConfig) {
        return MaterialFolderSearchControllerApiFp(this.configuration).executeSearchMaterialfolderGet(folderName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MobileApi - axios parameter creator
 * @export
 */
export const MobileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStream: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getStream', 'name', name)
            const localVarPath = `/stream/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MobileApi - functional programming interface
 * @export
 */
export const MobileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MobileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStream(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStream(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MobileApi.getStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MobileApi - factory interface
 * @export
 */
export const MobileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MobileApiFp(configuration)
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStream(name: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getStream(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MobileApi - object-oriented interface
 * @export
 * @class MobileApi
 * @extends {BaseAPI}
 */
export class MobileApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MobileApi
     */
    public getStream(name: string, options?: RawAxiosRequestConfig) {
        return MobileApiFp(this.configuration).getStream(name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileControllerApi - axios parameter creator
 * @export
 */
export const ProfileControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/profile/broadcasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/profile/materialFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/profile/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/profile/referenceMaterials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileControllerApi - functional programming interface
 * @export
 */
export const ProfileControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor111(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor111(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileControllerApi.descriptor111']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor112(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor112(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileControllerApi.descriptor112']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor113(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor113(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileControllerApi.descriptor113']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async descriptor114(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.descriptor114(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileControllerApi.descriptor114']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepresentationModelObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFormsOfMetadata1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileControllerApi.listAllFormsOfMetadata1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileControllerApi - factory interface
 * @export
 */
export const ProfileControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor111(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.descriptor111(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor112(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.descriptor112(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor113(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.descriptor113(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptor114(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.descriptor114(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFormsOfMetadata1(options?: RawAxiosRequestConfig): AxiosPromise<RepresentationModelObject> {
            return localVarFp.listAllFormsOfMetadata1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileControllerApi - object-oriented interface
 * @export
 * @class ProfileControllerApi
 * @extends {BaseAPI}
 */
export class ProfileControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor111(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor111(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor112(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor112(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor113(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor113(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public descriptor114(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).descriptor114(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileControllerApi
     */
    public listAllFormsOfMetadata1(options?: RawAxiosRequestConfig) {
        return ProfileControllerApiFp(this.configuration).listAllFormsOfMetadata1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (page?: number, size?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer Authentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModelEntityModelUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<PagedModelEntityModelUserDto> {
            return localVarFp.getUsers(page, size, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsers(page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUsers(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }
}



